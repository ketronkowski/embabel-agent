[[reference.annotations]]
=== Annotation model

Embabel provides a Spring-style annotation model to define agents, actions, goals, and conditions.
This is the recommended model to use in Java, and remains compelling in Kotlin.

==== The `@Agent` annotation

This annotation is used on a class to define an agent.
It is a Spring stereotype annotation, so it triggers Spring component scanning.
Your agent class will automatically be registered as a Spring bean.
It will also be registered with the agent framework, so it can be used in agent processes.

You must provide the `description` parameter, which is a human-readable description of the agent.
This is particularly important as it may be used by the LLM in agent selection.

==== The `@Action` annotation

The `@Action` annotation is used to mark methods that perform actions within an agent.

Action metadata can be specified on the annotation, including:

- `description`: A human-readable description of the action.
- `pre`: A list of preconditions _additional to the input types_ that must be satisfied before the action can be executed.
- `post`: A list of postconditions _additional to the output type(s)_ that may be satisfied after the action is executed.
- `canRerun`: A boolean indicating whether the action can be rerun if it has already been executed.
Defaults to false.
- `clearBlackboard`: A boolean indicating whether to clear the blackboard after this action completes.
When true, all objects on the blackboard are removed except the action's output.
This is useful for resetting context in multi-step workflows.
It can also make persistence of flows more efficient by dispensing with objects that are no longer needed.
Defaults to false.
- `cost`:Relative cost of the action from 0-1. Defaults to 0.0.
- `value`: Relative value of performing the action from 0-1. Defaults to 0.0.
- `toolGroups`: Named tool groups the action requires.
- `toolGroupRequirements`: Tool group requirements with QoS constraints.

===== Clearing the Blackboard

The `clearBlackboard` attribute is useful in multi-step workflows where you want to reset the processing context.
When an action with `clearBlackboard = true` completes, all objects on the blackboard are removed except the action's output.
This prevents accumulated intermediate data from affecting subsequent processing.

[source,java]
----
@Agent(description = "Multi-step document processing")
public class DocumentProcessor {

    @Action(clearBlackboard = true)  // <1>
    public ProcessedDocument preprocess(RawDocument doc) {
        return new ProcessedDocument(doc.getContent().trim());
    }

    @AchievesGoal(description = "Produce final output")
    @Action
    public FinalOutput transform(ProcessedDocument doc) {  // <2>
        return new FinalOutput(doc.getContent().toUpperCase());
    }
}
----

<1> After `preprocess` completes, the blackboard is cleared and only `ProcessedDocument` remains.
The original `RawDocument` is removed.
<2> The `transform` action receives only the `ProcessedDocument`, not any earlier inputs.

NOTE: Avoid using `clearBlackboard` on goal-achieving actions (those with `@AchievesGoal`).
Clearing the blackboard removes `hasRun` tracking conditions, which may interfere with goal satisfaction.
Use `clearBlackboard` on intermediate actions instead.

//TODO: (jasper notes) Provide links to detailed docs for pre, post, canRerun, cost, etc. Also brief code example is useful here.

===== Dynamic Cost Computation with `@Cost`

While the `cost` and `value` fields on `@Action` allow specifying static values, you can compute these dynamically at planning time using the `@Cost` annotation.
This is useful when the cost of an action depends on the current state of the blackboard.

The `@Cost` annotation marks a method that returns a cost value (a `double` between 0.0 and 1.0).
You then reference this method from the `@Action` annotation using `costMethod` or `valueMethod`.

[source,java]
----
@Agent(description = "Processor with dynamic cost")
public class DataProcessor {

    @Cost(name = "processingCost")  // <1>
    public double computeProcessingCost(@Nullable LargeDataSet data) {  // <2>
        if (data != null && data.size() > 1000) {
            return 0.9;  // High cost for large datasets
        }
        return 0.1;  // Low cost for small or missing datasets
    }

    @Action(costMethod = "processingCost")  // <3>
    public ProcessedData process(RawData input) {
        return new ProcessedData(input.transform());
    }
}
----

<1> The `@Cost` annotation marks a method for dynamic cost computation.
The `name` parameter identifies this cost method.
<2> Domain object parameters in `@Cost` methods must be nullable.
If the object isn't on the blackboard, `null` is passed.
<3> The `costMethod` field references the `@Cost` method by name.

Key differences from `@Condition` methods:

* All domain object parameters in `@Cost` methods must be nullable (use `@Nullable` in Java or `?` in Kotlin)
* When a domain object is not available on the blackboard, `null` is passed instead of causing the method to fail
* The method must return a `double` between 0.0 and 1.0
* The `Blackboard` can be passed as a parameter for direct access to all available objects

You can also compute dynamic value using `valueMethod`:

[source,kotlin]
----
@Agent(description = "Agent with dynamic value computation")
class PrioritizedAgent {

    @Cost(name = "urgencyValue")
    fun computeUrgency(task: Task?): Double {
        return when {
            task == null -> 0.5
            task.priority == Priority.HIGH -> 1.0
            task.priority == Priority.MEDIUM -> 0.6
            else -> 0.2
        }
    }

    @AchievesGoal(description = "Process high-priority tasks")
    @Action(valueMethod = "urgencyValue")
    fun processTask(task: Task): Result {
        return Result("Processed: ${task.name}")
    }
}
----

NOTE: The `@Cost` method is called during planning, before the action executes.
It allows the planner to make informed decisions about which actions to prefer based on runtime state.

TIP: Dynamic cost is especially useful with *Utility planning* (`PlannerType.UTILITY`), where cost/value tradeoffs are a core concept.
The utility planner evaluates actions based on their net value (value minus cost), making dynamic cost computation essential for sophisticated decision-making.

==== The `@Condition` annotation

The `@Condition` annotation is used to mark methods that evaluate conditions.
They can take an `OperationContext` parameter to access the blackboard and other infrastructure.
If they take domain object parameters, the condition will automatically be false until suitable instances are available.

> Condition methods should not have side effects--for example, on the blackboard.
This is important because they may be called multiple times.

//TODO (jasper notes) Provide a simple illustrative example with story-telling and supporting code example.

> Both Action and Condition methods may be inherited from superclasses.
That is, annotated methods on superclasses will be treated as actions on a subclass instance.

> Give your Action and Condition methods unique names, so the planner can distinguish between them.

==== Parameters

`@Action` methods must have at least one parameter.
`@Condition` methods must have zero or more parameters, but otherwise follow the same rules as `@Action` methods regarding parameters.
Ordering of parameters is not important.

Parameters fall in two categories:

* _Domain objects_.
These are the normal inputs for action methods.
They are backed by the blackboard and will be used as inputs to the action method.
A nullable domain object parameter will be populated if it is non-null on the blackboard.
This enables nice-to-have parameters that are not required for the action to run.
In Kotlin, use a nullable parameter with `?`: in Java, mark the parameter with the `org.springframework.lang.Nullable` or another `Nullable` annotation.

* _Infrastructure parameters_, such as the `OperationContext`, `ProcessContext`, and `Ai` may be used in action or condition methods.

NOTE: Domain objects drive planning, specifying the preconditions to an action.

The `ActionContext` or `ExecutingOperationContext` subtype can be used in action methods.
It adds `asSubProcess` methods that can be used to run other agents in subprocesses.
This is an important element of composition.

> Use the least specific type possible for parameters.
Use `OperationContext` unless you are creating a subprocess.

===== Custom Parameters

Besides two default parameter categories described above, you can provide your own parameters by implementing the `ActionMethodArgumentResolver` interface.
The two main methods of this interface are:

* `supportsParameter`, which indicates what kind of parameters are supported, and
* `resolveArgument`, which resolves the argument into an object used to invoke the action method.

NOTE: Note the similarity with Spring MVC, where you can provide custom parameters by implementing a `HandlerMethodArgumentResolver`.

> All default parameters are provided by `ActionMethodArgumentResolver` implementations.

To register your custom argument resolver, provide it to the `DefaultActionMethodManager` component in your Spring configuration.
Typically, you will register (some of) the defaults as well your custom resolver, in order to support the default parameters.

TIP: Make sure to register the `BlackboardArgumentResolver` as last resolver, to ensure that others take precedence.

==== Binding by name

The `@RequireNameMatch` annotation can be used to <<reference.flow__binding, bind parameters by name>>.

//TODO: (jasper notes) Provide an illustrative code example here.

==== Reactive triggers with `trigger`

The `trigger` field on the `@Action` annotation enables reactive behavior where an action only fires when a specific type is the _most recently added_ value to the blackboard.
This is useful in event-driven scenarios where you want to react to a particular event even when multiple parameters of various types are available.

For example, in a chat system you might want an action to fire only when a new user message arrives, not when other context is updated:

[source,java]
----
@Agent(description = "Chat message handler")
public class ChatAgent {

    @AchievesGoal(description = "Respond to user message")
    @Action(trigger = UserMessage.class)  // <1>
    public Response handleMessage(
            UserMessage message,
            Conversation conversation  // <2>
    ) {
        return new Response("Received: " + message.content());
    }
}
----

<1> The `trigger` field means this action only fires when `UserMessage` is the last result added to the blackboard.
<2> `Conversation` must also be available, but doesn't need to be the triggering event.

Without `trigger`, an action fires as soon as all its parameters are available on the blackboard.
With `trigger`, the specified type must additionally be the most recent value added.

This is particularly useful when:

* You have multiple actions that could handle different event types
* You want to distinguish between "data available" and "event just occurred"
* You're building event-driven or reactive workflows

[source,java]
----
@Agent(description = "Multi-event processor")
public class EventProcessor {

    @Action(trigger = EventA.class)  // <1>
    public Result handleEventA(EventA eventA, EventB eventB) {
        return new Result("Triggered by A");
    }

    @AchievesGoal(description = "Handle event B")
    @Action(trigger = EventB.class)  // <2>
    public Result handleEventB(EventA eventA, EventB eventB) {
        return new Result("Triggered by B");
    }
}
----

<1> `handleEventA` fires when `EventA` is added (and `EventB` is available).
<2> `handleEventB` fires when `EventB` is added (and `EventA` is available).

NOTE: The `trigger` field checks that the specified type matches the `lastResult()` on the blackboard.
The last result is the most recent object added via any binding operation.

==== Handling of return types

Action methods normally return a single domain object.

Nullable return types are allowed.
Returning null will trigger replanning.
There may or not be an alternative path from that point, but it won't be what the planner was previously trying to achieve.

//TODO: (jasper notes) A diagram showing this would be super cool here.

There is a special case where the return type can essentially be a union type, where the action method can return one ore more of several types.
This is achieved by a return type implementing the `SomeOf` tag interface.
Implementations of this interface can have multiple nullable fields.
Any non-null values will be bound to the blackboard, and the postconditions of the action will include all possible fields of the return type.

For example:

[source,kotlin]
----
// Must implement the SomeOf interface
data class FrogOrDog(
    val frog: Frog? = null,
    val dog: Dog? = null,
) : SomeOf

@Agent(description = "Illustrates use of the SomeOf interface")
class ReturnsFrogOrDog {

    @Action
    fun frogOrDog(): FrogOrDog {
        return FrogOrDog(frog = Frog("Kermit"))
    }

    // This works because the frog field of the return type was set
    @AchievesGoal(description = "Create a prince from a frog")
    @Action
    fun toPerson(frog: Frog): PersonWithReverseTool {
        return PersonWithReverseTool(frog.name)
    }
}
----

This enables routing scenarios in an elegant manner.

TIP: Multiple fields of the `SomeOf` instance may be non-null and this is not an error.
It may enable the most appropriate routing.

Routing can also be achieved via subtypes, as in the following example:

[source,kotlin]
----
@Action
fun classifyIntent(userInput: UserInput): Intent? = // <1>
    when (userInput.content) {
        "billing" -> BillingIntent()
        "sales" -> SalesIntent()
        "service" -> ServiceIntent()
        else -> {
            loggerFor<IntentReceptionAgent>().warn("Unknown intent: $userInput")
            null
        }
    }

@Action
fun billingAction(intent: BillingIntent): IntentClassificationSuccess { // <2>
    return IntentClassificationSuccess("billing")
}

@Action
fun salesAction(intent: SalesIntent): IntentClassificationSuccess {
    return IntentClassificationSuccess("sales")
}

// ...
----

<1> Classification action returns supertype `Intent`.
Real classification would likely use an LLM.
<2> `billingAction` and other action methods takes a subtype of `Intent`, so will only be invoked if the classification action returned that subtype.

==== Action method implementation

Embabel makes it easy to seamlessly integrate LLM invocation and application code, using common types.
An `@Action` method is a normal method, and can use any libraries or frameworks you like.

The only special thing about it is its ability to use the `OperationContext` parameter to access the blackboard and invoke LLMs.

==== The `@AchievesGoal` annotation

The `@AchievesGoal` annotation can be added to an `@Action` method to indicate that the completion of the action achieves a specific goal.

==== Implementing the `StuckHandler` interface

If an annotated agent class implements the `StuckHandler` interface, it can handle situations where an action is stuck itself.
For example, it can add data to the blackboard.

//TODO: (japer notes) Provide concrete examples of when StuckHandler is useful.

Example:

[source,kotlin]
----
@Agent(
    description = "self unsticking agent",
)
class SelfUnstickingAgent : StuckHandler {

    // The agent will get stuck as there's no dog to convert to a frog
    @Action
    @AchievesGoal(description = "the big goal in the sky")
    fun toFrog(dog: Dog): Frog {
        return Frog(dog.name)
    }

    // This method will be called when the agent is stuck
    override fun handleStuck(agentProcess: AgentProcess): StuckHandlerResult {
        called = true
        agentProcess.addObject(Dog("Duke"))
        return StuckHandlerResult(
            message = "Unsticking myself",
            handler = this,
            code = StuckHandlingResultCode.REPLAN,
            agentProcess = agentProcess,
        )
    }
}
----

==== Advanced Usage: Nested processes

An `@Action` method can invoke another agent process.
This is often done to use a stereotyped process that is composed using the DSL.

Use the `ActionContext.asSubProcess` method to create a sub-process from the action context.

For example:

[source,kotlin]
----
@Action
fun report(
    reportRequest: ReportRequest,
    context: ActionContext,
): ScoredResult<Report, SimpleFeedback> = context.asSubProcess(
    // Will create an agent sub process with strong typing
    EvaluatorOptimizer.generateUntilAcceptable(
        maxIterations = 5,
        generator = {
            it.promptRunner().withToolGroup(CoreToolGroups.WEB).create(
                """
        Given the topic, generate a detailed report in ${reportRequest.words} words.

        # Topic
        ${reportRequest.topic}

        # Feedback
        ${it.input ?: "No feedback provided"}
                """.trimIndent()
            )
        },
        evaluator = {
            it.promptRunner().withToolGroup(CoreToolGroups.WEB).create(
                """
        Given the topic and word count, evaluate the report and provide feedback
        Feedback must be a score between 0 and 1, where 1 is perfect.

        # Report
        ${it.input.report}

        # Report request:

        ${reportRequest.topic}
        Word count: ${reportRequest.words}
        """.trimIndent()
            )
        },
    ))
----

