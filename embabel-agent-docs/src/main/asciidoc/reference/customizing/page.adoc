[[reference.customizing]]
=== Customizing Embabel

==== Adding LLMs

You can add custom LLMs as Spring beans of type `Llm`.

`Llm` instances are created around Spring AI `ChatModel` instances.

You can use any Spring AI compatible model, adding additional Embabel requirements:

- name (required)
- provider, such as "Mistral" (required)
- `OptionsConverter` to convert Embabel `LlmOptions` to Spring AI `ChatOptions`
- *knowledge cutoff date* (if available)
- any additional `PromptContributor` objects to be used in all LLM calls.
If knowledge cutoff date is provided, add the `KnowledgeCutoffDate` prompt contributor.
- pricing model (if available)

For example:

[source,java]
----
@Configuration
public class LlmsConfig {
    @Bean
    public Llm myLlm() {
        org.springframework.ai.chat.model.ChatModel chatModel = ...
        return new Llm(
                "myChatModel",
                "myChatModelProvider",
                chatModel)
            .withOptionsConverter(new MyLlmOptionsConverter()) // <1>
            .withKnowledgeCutoffDate(LocalDate.of(2025, 4, 1)); //<2>
    }
}
----

<1> Customize the `Llm` instance with an `OptionsConverter` implementation to convert Embabel `LlmOptions` to Spring AI `ChatOptions`.
This is recommended.
<2> Set the knowledge cutoff date if available.
This will automatically expose it to prompts via the `KnowledgeCutoffDate` prompt contributor.

A common requirement is to add an open AI compatible LLM.
This can be done by extending the `OpenAiCompatibleModelFactory` class as follows:

[source,kotlin]
----
@Configuration
class CustomOpenAiCompatibleModels(
    @Value("\${MY_BASE_URL:#{null}}")
    baseUrl: String?,
    @Value("\${MY_API_KEY}")
    apiKey: String,
    observationRegistry: ObservationRegistry,
) : OpenAiCompatibleModelFactory(baseUrl = baseUrl, apiKey = apiKey, observationRegistry = observationRegistry) {

    @Bean
    fun myGreatModel(): Llm {
        // Call superclass method
        return openAiCompatibleLlm(
            model = "my-great-model",
            provider = "me",
            knowledgeCutoffDate = LocalDate.of(2025, 1, 1),
            pricingModel = PerTokenPricingModel(
                usdPer1mInputTokens = .40,
                usdPer1mOutputTokens = 1.6,
            )
        )
    }
}
----

==== Adding embedding models

Embedding models can also be added as beans of the Embabel type `EmbeddingService`.

Typically, this is done in an `@Configuration` class like this:

[source,java]
----
@Configuration
public class EmbeddingModelsConfig {
    @Bean
    public EmbeddingService myEmbeddingModel() {
        org.springframework.ai.embedding.EmbeddingModel embeddingModel = ...
        return new EmbeddingService(
                "myEmbeddingModel",
                "myEmbeddingModelProvider",
                embeddingModel);
    }
}
----

==== Configuration via `application.properties` or `application.yml`

You can specify Spring configuration, your own configuration and Embabel configuration in the regular Spring configuration files.
Profile usage will work as expected.

==== Customizing logging

You can customize logging as in any Spring application.

For example, in `application.properties` you can set properties like:

[source,properties]
----
logging.level.com.embabel.agent.a2a=DEBUG
----

You can also configure logging via a `logback-spring.xml` file if you have more sophisticated requirements.

See the https://docs.spring.io/spring-boot/reference/features/logging.html[Spring Boot Logging] reference.

By default, many Embabel examples use personality-based logging experiences such as Star Wars.
You can disable this via the `@EnableAgents` annotation on your main application class:

[source,java]
----
@SpringBootApplication
@ConfigurationPropertiesScan
@EnableAgents(
        loggingTheme = LoggingThemes.STAR_WARS
)
class MyAwesomeApplication {
    public static void main(String[] args) {
        SpringApplication.run(GuideApplication.class, args);
    }
}
----

Remove the `loggingTheme` attribute to disable personality-based logging.

As all logging results from listening to events via an `AgenticEventListener`, you can also easily create your own customized logging.


