[[reference.planners]]
=== Choosing a Planner

Embabel supports multiple planning strategies.
All are deterministic, but their behaviour differs--although it is always predictable.

All planning strategies are entirely typesafe in Java or Kotlin.

The planning strategies currently supported out of the box are:

[cols="1,2,3",options="header"]
|===
|Planner |Best For |Description

|*GOAP* (default)
|Business processes with defined outputs
|Goal-oriented, deterministic planning. Plans a path from current state to goal using preconditions and effects.

|*Utility*
|Exploration and event-driven systems
|Selects the highest-value available action at each step. Ideal when you don't know the outcome upfront.
|===

As most of the documentation covers GOAP, this section discusses the alternative planners and nested workflows.

[[reference.planners__utility]]
==== Utility AI

https://en.wikipedia.org/wiki/Utility_system[Utility AI] selects the action with the highest _net value_ from all available actions at each step.
Unlike GOAP, which plans a path to a goal, Utility AI makes greedy decisions based on immediate value.

Utility AI excels in *exploratory scenarios* where you don't know exactly what you want to achieve.
Consider a GitHub issue triage system: when a new issue arrives, you don't have a predetermined goal.
Instead, you want to react appropriately based on the issue's characteristics--maybe label it, maybe respond, maybe escalate.
The "right" action depends on what you discover as you process it.

This makes Utility AI ideal for scenarios where:

* There is no clear end goal--you're exploring possibilities
* Multiple actions could be valuable depending on context
* You want to respond to changing conditions as they emerge
* The best outcome isn't known upfront

===== When to Use Utility AI

* *Event-driven systems*: React to incoming events (issues, stars, webhooks) with the most appropriate action
* *Chatbots*: Where the platform provides multiple response options and selects the best one
* *Exploration*: When you want to discover what's possible rather than achieve a specific goal

===== Using Utility AI with `@EmbabelComponent`

For Utility AI, actions are typically provided via `@EmbabelComponent` rather than `@Agent`.
This allows the _platform_ to select actions across multiple components based on utility, rather than constraining actions to a single agent.

Here's an example from the Shepherd project that reacts to GitHub events:

[source,kotlin]
----
@EmbabelComponent  // <1>
class IssueActions(
    val properties: ShepherdProperties,
    private val communityDataManager: CommunityDataManager,
    private val gitHubUpdater: GitHubUpdater,
) {

    @Action(outputBinding = "ghIssue")  // <2>
    fun saveNewIssue(ghIssue: GHIssue, context: OperationContext): GHIssue? {
        val existing = communityDataManager.findIssueByGithubId(ghIssue.id)
        if (existing == null) {
            val issueEntityStatus = communityDataManager.saveAndExpandIssue(ghIssue)
            context += issueEntityStatus  // <3>
            return ghIssue
        }
        return null  // <4>
    }

    @Action(
        pre = ["spel:newEntity.newEntities.?[#this instanceof T(com.embabel.shepherd.domain.Issue)].size() > 0"]  // <5>
    )
    fun reactToNewIssue(
        ghIssue: GHIssue,
        newEntity: NewEntity<*>,
        ai: Ai
    ): IssueAssessment {
        return ai
            .withLlm(properties.triageLlm)
            .creating(IssueAssessment::class.java)
            .fromTemplate("first_issue_response", mapOf("issue" to ghIssue))  // <6>
    }

    @Action(pre = ["spel:issueAssessment.urgency > 0.0"])  // <7>
    fun heavyHitterIssue(issue: GHIssue, issueAssessment: IssueAssessment) {
        // Take action on high-urgency issues
    }
}
----

<1> `@EmbabelComponent` contributes actions to the platform, not a specific agent
<2> `outputBinding` names the result for later actions to reference
<3> Add entity status to context, making it available to subsequent actions
<4> Returning `null` prevents further actions from firing for this issue
<5> SpEL precondition: only fire if new issues were created
<6> Use AI to assess the issue via a template
<7> This action only fires if the assessment shows urgency > 0

The platform selects which action to run based on:

1. Which preconditions are satisfied (type availability + SpEL conditions)
2. The `cost` and `value` parameters on `@Action` (net value = value - cost)

===== Action Cost and Value

The `@Action` annotation supports `cost` and `value` parameters (both 0.0 to 1.0):

[source,kotlin]
----
@Action(
    cost = 0.1,   // <1>
    value = 0.8   // <2>
)
fun highValueAction(input: Input): Output {
    // Action implementation
}
----

<1> Cost to execute (0.0 to 1.0) - lower is cheaper
<2> Value when executed (0.0 to 1.0) - higher is more valuable

The Utility planner calculates _net value_ as `value - cost` and selects the action with the highest net value from all available actions.

===== The Nirvana Goal

Utility AI supports a special "Nirvana" goal that is never satisfied.
This keeps the process running, continuously selecting the highest-value available action until no actions are available.

===== Extensibility

Utility AI fosters extensibility.
For example, multiple groups within an organization can contribute their own `@EmbabelComponent` classes with actions that bring their own expertise to enhance behaviours around shared types, while retaining the ability to own and control their own extended model.

===== Utility and States

Utility AI can combine with the `@State` annotation to implement classification and routing patterns.
This is particularly useful when you need to:

* *Classify input* into different categories at runtime
* *Route processing* through category-specific handlers
* *Achieve different goals* based on classification

The key pattern is:

1. An entry action classifies input and returns a `@State` type
2. Each `@State` class contains an `@AchievesGoal` action that produces the final output
3. The `@AchievesGoal` output is _not_ a `@State` type (to prevent infinite loops)

Here's an example of a ticket triage system that routes support tickets based on severity:

[source,kotlin]
----
@Agent(
    description = "Triage and process support tickets",
    planner = PlannerType.UTILITY  // <1>
)
class TicketTriageAgent {

    data class Ticket(val id: String, val description: String, val customerId: String)
    data class ResolvedTicket(val id: String, val resolution: String, val handledBy: String)

    @State
    sealed interface TicketCategory  // <2>

    @Action
    fun triageTicket(ticket: Ticket): TicketCategory {  // <3>
        return when {
            ticket.description.contains("down", ignoreCase = true) ->
                CriticalTicket(ticket)
            ticket.description.contains("bug", ignoreCase = true) ->
                BugTicket(ticket)
            else ->
                GeneralTicket(ticket)
        }
    }

    @State
    data class CriticalTicket(val ticket: Ticket) : TicketCategory {
        @AchievesGoal(description = "Handle critical ticket with immediate escalation")  // <4>
        @Action
        fun handleCritical(): ResolvedTicket {
            return ResolvedTicket(
                id = ticket.id,
                resolution = "Escalated to on-call engineer",
                handledBy = "CRITICAL_RESPONSE_TEAM"
            )
        }
    }

    @State
    data class BugTicket(val ticket: Ticket) : TicketCategory {
        @AchievesGoal(description = "Handle bug report")
        @Action
        fun handleBug(): ResolvedTicket {
            return ResolvedTicket(
                id = ticket.id,
                resolution = "Bug logged in issue tracker",
                handledBy = "ENGINEERING_TEAM"
            )
        }
    }

    @State
    data class GeneralTicket(val ticket: Ticket) : TicketCategory {
        @AchievesGoal(description = "Handle general inquiry")
        @Action
        fun handleGeneral(): ResolvedTicket {
            return ResolvedTicket(
                id = ticket.id,
                resolution = "Response sent with FAQ links",
                handledBy = "SUPPORT_TEAM"
            )
        }
    }
}
----

<1> Use `PlannerType.UTILITY` for opportunistic action selection
<2> Sealed interface as the state supertype
<3> Entry action classifies and returns a `@State` instance
<4> Each state has an `@AchievesGoal` action producing the final output

When a `Ticket` is processed:

1. The `triageTicket` action classifies it into one of the state types
2. Entering a state clears other objects from the blackboard
3. The Utility planner selects the `@AchievesGoal` action for that state
4. The goal is achieved when `ResolvedTicket` is produced

This pattern works well when:

* Classification determines the processing path
* Each category has distinct handling requirements
* The final output type is the same across all categories
