[[reference.integrations]]
=== Integrations

[[reference.integrations__mcp]]
==== Model Context Protocol (MCP)

===== Publishing

====== Overview

Embabel Agent can expose your agents as MCP servers, making them available to external MCP clients such as Claude Desktop, VS Code extensions, or other MCP-compatible applications.
The framework provides automatic publishing of agent goals as tools and prompts without requiring manual configuration.

====== Server Configuration

Configure MCP server functionality in your `application.yml`.
The server type determines the execution mode:

[source,yaml]
----
spring:
  ai:
    mcp:
      server:
        type: SYNC  # or ASYNC
----

====== Server Types

Embabel Agent supports two MCP server execution modes controlled by the `spring.ai.mcp.server.type` property:

**SYNC Mode** (Default)::
- Blocking operations wrapped in reactive streams
- Simpler to develop and debug
- Suitable for most use cases
- Better error handling and logging

[source,yaml]
----
spring:
  ai:
    mcp:
      server:
        type: SYNC
----

**ASYNC Mode**::
- True non-blocking reactive operations
- Higher throughput for concurrent requests
- More complex error handling
- Suitable for high-performance scenarios

[source,yaml]
----
spring:
  ai:
    mcp:
      server:
        type: ASYNC
----

====== Automatic Publishing

**Tools**::
Agent goals are automatically published as MCP tools when annotated with `@Export(remote = true)`.
The `PerGoalMcpToolExportCallbackPublisher` automatically discovers and exposes these goals without any additional configuration.

**Prompts**::
Prompts are automatically generated for each goal's starting input types through the `PerGoalStartingInputTypesPromptPublisher`.
This provides ready-to-use prompt templates based on your agent definitions.

====== Exposing Agent Goals as Tools

Agent goals become MCP tools automatically when annotated with `@Export`:

[source,java]
----
@Agent(
    goal = "Provide weather information",
    backstory = "Weather service agent"
)
public class WeatherAgent {
    
    @Goal
    @Export(remote = true)  // Automatically becomes MCP tool
    public String getWeather(
        @Param("location") String location,
        @Param("units") String units
    ) {
        return "Weather for " + location + " in " + units;
    }
    
    @Goal
    public String internalMethod() {
        // Not exposed to MCP (no @Export annotation)
        return "Internal use only";
    }
}
----

====== Exposing Embabel `ToolObject` and `LlmReference` types as tools

A common requirement is to expose existing Embabel functionality via MCP.
For example, an `LlmReference` might be added to a `PromptRunner` but might also be used as an external tool via MCP.

To do this, use `McpToolExport` to create a bean of type `McpToolExportCallbackPublisher`.

For example, to expose a `ToolishRag` LLM reference as an MCP tool, define a Spring configuration class as follows:

[source,java]
----
@Configuration
public class RagMcpTools {

    @Bean
    McpToolExport ragTools( // <1>
            SearchOperations searchOperations) {
        var toolishRag = new ToolishRag(
                "docs",
                "Embabel docs",
                searchOperations
        );
        return McpToolExport.fromLlmReference(toolishRag); // <2>
    }
}
----

<1> Your bean should be of type `McpToolExport`
<2> Use `McpToolExport.fromLlmReference` to return the instance

====== Naming Strategies

When exporting tools, you can control how tool names are transformed using a naming strategy.
This is useful for namespacing tools when exporting from multiple sources to avoid naming conflicts.

**Using ToolObject with a naming strategy:**

[source,kotlin]
----
@Bean
fun prefixedTools(): McpToolExport {
    return McpToolExport.fromToolObject(
        ToolObject(
            objects = listOf(myToolInstance),
            namingStrategy = { "myservice_$it" }  // <1>
        )
    )
}
----

<1> All tool names will be prefixed with `myservice_`

Common naming strategies include:

* **Prefix**: `{ "namespace_$it" }` - adds a prefix to avoid conflicts
* **Uppercase**: `{ it.uppercase() }` - converts to uppercase
* **Identity**: `StringTransformer.IDENTITY` - preserves original names (default)

**LlmReference naming:**

When using `fromLlmReference`, the reference's built-in naming strategy is applied automatically.
This prefixes tool names with the lowercased, normalized reference name.
For example, an `LlmReference` named "MyAPI" will prefix all tools with `myapi_`.

[source,kotlin]
----
// Reference named "WeatherService" will prefix tools with "weatherservice_"
val reference = MyWeatherReference()  // name = "WeatherService"
McpToolExport.fromLlmReference(reference)
// Tool "getWeather" becomes "weatherservice_getWeather"
----

**Exporting multiple sources with different prefixes:**

[source,kotlin]
----
@Bean
fun multiSourceTools(): McpToolExport {
    return McpToolExport.fromToolObjects(
        listOf(
            ToolObject(
                objects = listOf(weatherTools),
                namingStrategy = { "weather_$it" }
            ),
            ToolObject(
                objects = listOf(stockTools),
                namingStrategy = { "stocks_$it" }
            )
        )
    )
}
----

====== Filtering Tools

You can filter which tools are exported using the `filter` property on `ToolObject`:

[source,kotlin]
----
@Bean
fun filteredTools(): McpToolExport {
    return McpToolExport.fromToolObject(
        ToolObject(
            objects = listOf(myToolInstance),
            filter = { it.startsWith("public_") }  // <1>
        )
    )
}
----

<1> Only tools whose names start with `public_` will be exported

You can combine naming strategies and filters:

[source,kotlin]
----
@Bean
fun combinedTools(): McpToolExport {
    return McpToolExport.fromToolObject(
        ToolObject(
            objects = listOf(myToolInstance),
            namingStrategy = { "api_$it" },
            filter = { !it.startsWith("internal") }  // <1>
        )
    )
}
----

<1> The filter is applied to the original tool name before the naming strategy transforms it

====== Exposing Tools on Spring Components in Spring AI style

It is also possible to expose tools on Spring components as with regular Spring AI.

For example:

[source,java]
----
@Component
public class CalculatorTools {

    @McpTool(name = "add", description = "Add two numbers together")
    public int add(
            @McpToolParam(description = "First number", required = true) int a,
            @McpToolParam(description = "Second number", required = true) int b) {
        return a + b;
    }

    @McpTool(name = "multiply", description = "Multiply two numbers")
    public double multiply(
            @McpToolParam(description = "First number", required = true) double x,
            @McpToolParam(description = "Second number", required = true) double y) {
        return x * y;
    }
}
----

Of course, you can inject the Embabel `Ai` interface to help do the work of the tools if you wish, or invoke other agents from within the tool methods.

For further information, see the https://docs.spring.io/spring-ai/reference/api/mcp/mcp-annotations-overview.html[Spring AI MCP Annotations Reference].

====== Server Architecture

The MCP server implementation uses several design patterns:

**Template Method Pattern**::
- `AbstractMcpServerConfiguration` provides common initialization logic
- Concrete implementations (`McpSyncServerConfiguration`, `McpAsyncServerConfiguration`) handle mode-specific details

**Strategy Pattern**::
- Server strategies abstract sync vs async operations
- Mode-specific implementations handle tool, resource, and prompt management

**Publisher Pattern**::
- Tools, resources, and prompts are discovered through publisher interfaces
- Automatic registration and lifecycle management
- Event-driven initialization ensures proper timing

====== Built-in Tools

Every MCP server includes a built-in `helloBanner` tool that displays server information:

[source,json]
----
{
  "type": "banner",
  "mode": "SYNC",
  "lines": [
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "Embabel Agent MCP SYNC Server",
    "Version: 0.3.0-SNAPSHOT",
    "Java: 21.0.2+13-LTS-58",
    "Started: 2025-01-17T14:23:47.785Z",
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  ]
}
----

[[reference.integrations__a2a]]
==== A2A

