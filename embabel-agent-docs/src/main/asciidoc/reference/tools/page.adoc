[[reference.tools]]
=== Tools

Tools can be passed to LLMs to allow them to perform actions.
Tools can either be outside the JVM process, as with MCP, or inside the JVM process, as with domain objects exposing `@Tool` methods.

Embabel allows you to provide tools to LLMs in two ways:

* Via the `PromptRunner` by providing one or more in process **tool instances**.
A tool instance is an object annotated with `@Tool` methods.
* At action or `PromptRunner` level, from a **tool group**.

`LlmReference` implementations also expose tools, but this is handled internally by the framework.

==== In Process Tools: Implementing Tool Instances

Implement one or more methods annotated with `@Tool` on a class.
You do not need to annotate the class itself.
Each annotated method represents a distinct tool that will be exposed to the LLM.

A simple example of a tool method:

[source,kotlin]
----
class MathTools {

    @Tool(description = "add two numbers")
    fun add(a: Double, b: Double) = a + b

    // Other tools
----

Classes implementing tools can be stateful.
They are often domain objects.
Tools on mapped entities are especially useful, as they can encapsulate state that is never exposed to the LLM.
See https://medium.com/@springrod/domain-tools-direct-access-zero-ceremony-9a3e8d4cf550[Domain Tools: Direct Access, Zero Ceremony] for a discussion of tool use patterns.

The `@Tool` annotation comes from https://docs.spring.io/spring-ai/reference/api/tools.html[Spring AI].

Tool methods can have any visibility, and can be static or instance scope.
They are allowed on inner classes.

[quote,Spring AI,Tool Calling]
____
You can define any number of arguments for the method (including no argument) with most types (primitives, POJOs, enums, lists, arrays, maps, and so on).
Similarly, the method can return most types, including void.
If the method returns a value, the return type must be a serializable type, as the result will be serialized and sent back to the model.

The following types are not currently supported as parameters or return types for methods used as tools:

- Optional
- Asynchronous types (e.g. CompletableFuture, Future)
- Reactive types (e.g. Flow, Mono, Flux)
- Functional types (e.g. Function, Supplier, Consumer).
____

You can obtain the current `AgentProcess` in a Tool method implementation via `AgentProcess.get()`.
This enables tools to bind to the `AgentProcess`, making objects available to other actions.
For example:

[source,java]
----

@Tool(description="My Tool") String bindCustomer(Long id) {
var customer = customerRepository.findById(id); var agentProcess = AgentProcess.get(); if (agentProcess != null) {
agentProcess.addObject(customer); return "Customer bound to blackboard"; } return "No agent process: Unable to bind customer"; }

----

[[reference.tools__tool-groups]]
==== Tool Groups

Embabel introduces the concept of a *tool group*.
This is a level of indirection between user intent and tool selection.
For example, we don't ask for Brave or Google web search: we ask for "web" tools, which may be resolved differently in different environments.

TIP: Tools use should be focused.
Thus tool groups are not specified at agent level, but on individual actions.

Tool groups are often backed by <<reference.integrations__mcp,MCP>>.

===== Configuring Tool Groups in configuration files

If you have configured MCP servers in your application configuration, you can selectively expose tools from those servers to agents by configuring tool groups.
The easiest way to do this is in your `application.yml` or `application.properties` file.
Select tools by name.

For example:

[source,yaml]
----
embabel:

    agent:
    platform:
      tools:
        includes:
          weather:
            description: Get weather for location
            provider: Docker
            tools:
              - weather
----

===== Configuring Tool Groups in Spring @Configuration

You can also use Spring's `@Configuration` and `@Bean` annotations to expose ToolGroups to the agent platform with greater control.
The framework provides a default `ToolGroupsConfiguration` that demonstrates how to inject MCP servers and selectively expose MCP tools:

[source,kotlin]
----

@Configuration class ToolGroupsConfiguration(
    private val mcpSyncClients: List<McpSyncClient>) {

    @Bean
    fun mathToolGroup() = MathTools()

    @Bean
    fun mcpWebToolsGroup(): ToolGroup { // <1>
        return McpToolGroup(
            description = CoreToolGroups.WEB_DESCRIPTION,
            name = "docker-web",
            provider = "Docker",
            permissions = setOf(ToolGroupPermission.INTERNET_ACCESS),
            clients = mcpSyncClients,
            filter = {
                // Only expose specific web tools, exclude rate-limited ones
                (it.toolDefinition.name().contains("brave") ||
                 it.toolDefinition.name().contains("fetch")) &&
                !it.toolDefinition.name().contains("brave_local_search")
            }
        )
    }
}
----

<1> This method creates a Spring bean of type `ToolGroup`.
This will automatically be picked up by the agent platform, allowing the tool group to be requested by name (role).

===== Key Configuration Patterns

**MCP Client Injection:**
The configuration class receives a `List<McpSyncClient>` via constructor injection.
Spring automatically provides all available MCP clients that have been configured in the application.

**Selective Tool Exposure:**
Each `McpToolGroup` uses a `filter` lambda to control which tools from the MCP servers are exposed to agents.
This allows fine-grained control over tool availability and prevents unwanted or problematic tools from being used.

**Tool Group Metadata:**
Tool groups include descriptive metadata like `name`, `provider`, and `description` to help agents understand their capabilities.
The `permissions` property declares what access the tool group requires (e.g., `INTERNET_ACCESS`).

===== Creating Custom Tool Group Configurations

Applications can implement their own `@Configuration` classes to expose custom tool groups, which can be backed by any service or resource, not just MCP.

[source,java]
----
@Configuration
public class MyToolGroupsConfiguration {

    @Bean
    public ToolGroup databaseToolsGroup(DataSource dataSource) {
        return new DatabaseToolGroup(dataSource);
    }

    @Bean
    public ToolGroup emailToolsGroup(EmailService emailService) {
        return new EmailToolGroup(emailService);
    }
}
----

This approach leverages Spring's dependency injection to provide tool groups with the services and resources they need, while maintaining clean separation of concerns between tool configuration and agent logic.

===== Tool Usage in Action Methods

The `toolGroups` parameter on `@Action` methods specifies which tool groups are required for that action to execute.
The framework automatically provides these tools to the LLM when the action runs.

Here's an example from the `StarNewsFinder` agent that demonstrates web tool usage:

[tabs]
====
Java::
+
[source,java]
----
// toolGroups specifies tools that are required for this action to run
@Action(toolGroups = {CoreToolGroups.WEB})
public RelevantNewsStories findNewsStories(
        StarPerson person, Horoscope horoscope, OperationContext context) {
    var prompt = """
            %s is an astrology believer with the sign %s.
            Their horoscope for today is:
                <horoscope>%s</horoscope>
            Given this, use web tools and generate search queries
            to find %d relevant news stories summarize them in a few sentences.
            Include the URL for each story.
            Do not look for another horoscope reading or return results directly about astrology;
            find stories relevant to the reading above.
            """.formatted(
            person.name(), person.sign(), horoscope.summary(), storyCount);

    return context.ai().withDefaultLlm().createObject(prompt, RelevantNewsStories.class);
}
----

Kotlin::
+
[source,kotlin]
----
// toolGroups specifies tools that are required for this action to run
@Action(toolGroups = [CoreToolGroups.WEB, CoreToolGroups.BROWSER_AUTOMATION])
internal fun findNewsStories(
    person: StarPerson,
    horoscope: Horoscope,
    context: OperationContext,
): RelevantNewsStories =
    context.ai().withDefaultLlm() createObject (
        """
        ${person.name} is an astrology believer with the sign ${person.sign}.
        Their horoscope for today is:
            <horoscope>${horoscope.summary}</horoscope>
        Given this, use web tools and generate search queries
        to find $storyCount relevant news stories summarize them in a few sentences.
        Include the URL for each story.
        Do not look for another horoscope reading or return results directly about astrology;
        find stories relevant to the reading above.
        """.trimIndent()
    )
----
====

===== Key Tool Usage Patterns

**Tool Group Declaration:**
The `toolGroups` parameter on `@Action` methods explicitly declares which tool groups the action needs.
This ensures the LLM has access to the appropriate tools when executing that specific action.

**Multiple Tool Groups:**
Actions can specify multiple tool groups (e.g., `[CoreToolGroups.WEB, CoreToolGroups.BROWSER_AUTOMATION]`) when they need different types of capabilities.

**Automatic Tool Provisioning:**
The framework automatically makes the specified tools available to the LLM during the action execution.
Developers don't need to manually manage tool availability - they simply declare what's needed.

**Tool-Aware Prompts:**
Prompts should explicitly instruct the LLM to use the available tools.
For example, "use web tools and generate search queries" clearly directs the LLM to utilize the web search capabilities.

===== Using Tools at PromptRunner Level

Instead of declaring tools at the action level, you can also specify tools directly on the `PromptRunner` for more granular control:

[source,kotlin]
----
// Add tool groups to a specific prompt
context.ai().withAutoLlm().withToolGroup(CoreToolGroups.WEB).create(
    """
    Given the topic, generate a detailed report using web research.

    # Topic
    ${reportRequest.topic}
    """.trimIndent()
)

// Add multiple tool groups
context.ai().withDefaultLlm()
    .withToolGroup(CoreToolGroups.WEB)
    .withToolGroup(CoreToolGroups.MATH)
    .createObject("Calculate stock performance with web data", StockReport::class)
----

**Adding Tool Objects with @Tool Methods:**

You can also provide domain objects with `@Tool` methods directly to specific prompts:

[source,java]
----
context.ai()
    .withDefaultLlm()
    .withToolObject(jokerTool)
    .createObject("Create a UserInput object for fun", UserInput.class);

// Add tool object with filtering and custom naming strategy
context.ai()
    .withDefaultLlm()
    .withToolObject(
        ToolObject(calculatorService)
            .withNamingStrategy { "calc_$it" }
            .withFilter { methodName -> methodName.startsWith("compute") }
    ).createObject("Perform calculations", Result.class);
----

**Available PromptRunner Tool Methods:**

- `withToolGroup(String)`: Add a single tool group by name
- `withToolGroup(ToolGroup)`: Add a specific ToolGroup instance
- `withToolGroups(Set<String>)`: Add multiple tool groups
- `withTools(vararg String)`: Convenient method to add multiple tool groups
- `withToolObject(Any)`: Add domain object with @Tool methods
- `withToolObject(ToolObject)`: Add ToolObject with custom configuration
- `withTool(Tool)`: Add a framework-agnostic Tool instance
- `withTools(List<Tool>)`: Add multiple framework-agnostic Tool instances

[[reference.tools__framework-agnostic]]
==== Framework-Agnostic Tool Interface

In addition to Spring AI's `@Tool` annotation, Embabel provides its own framework-agnostic `Tool` interface in the `com.embabel.agent.api.tool` package.
This allows you to create tools that are not tied to any specific LLM framework, making your code more portable and testable.

The `Tool` interface includes nested types to avoid naming conflicts with framework-specific types:

- `Tool.Definition` - Describes the tool (name, description, input schema)
- `Tool.InputSchema` - Defines the parameters the tool accepts
- `Tool.Parameter` - A single parameter with name, type, and description
- `Tool.Result` - The result returned by a tool (text, artifact, or error)
- `Tool.Context` - Optional execution context
- `Tool.Handler` - Functional interface for implementing tool logic

===== Creating Tools Programmatically

You can create tools using the `Tool.create()` factory methods:

[tabs]
====
Java::
+
[source,java]
----
// Simple tool with no parameters
Tool greetTool = Tool.create(
    "greet",
    "Greets the user",
    (input, ctx) -> Tool.Result.text("Hello!")
);

// Tool with parameters
Tool addTool = Tool.create(
    "add",
    "Adds two numbers together",
    Tool.InputSchema.of(
        new Tool.Parameter("a", Tool.ParameterType.INTEGER, "First number", true, null),
        new Tool.Parameter("b", Tool.ParameterType.INTEGER, "Second number", true, null)
    ),
    (input, ctx) -> {
        // Parse input JSON and compute result
        return Tool.Result.text("42");
    }
);

// Tool with metadata (e.g., return directly without LLM processing)
Tool directTool = Tool.create(
    "lookup",
    "Looks up data directly",
    Tool.Metadata.create(true), // returnDirect = true
    (input, ctx) -> Tool.Result.text("Direct result")
);
----

Kotlin::
+
[source,kotlin]
----
// Simple tool with no parameters
val greetTool = Tool.of(
    name = "greet",
    description = "Greets the user"
) { _, _ ->
    Tool.Result.text("Hello!")
}

// Tool with parameters
val addTool = Tool.of(
    name = "add",
    description = "Adds two numbers together",
    inputSchema = Tool.InputSchema.of(
        Tool.Parameter("a", Tool.ParameterType.INTEGER, "First number", true, null),
        Tool.Parameter("b", Tool.ParameterType.INTEGER, "Second number", true, null)
    )
) { input, _ ->
    // Parse input JSON and compute result
    Tool.Result.text("42")
}

// Tool with metadata
val directTool = Tool.of(
    name = "lookup",
    description = "Looks up data directly",
    metadata = Tool.Metadata(returnDirect = true)
) { _, _ ->
    Tool.Result.text("Direct result")
}
----
====

===== Creating Tools from Annotated Methods

Embabel provides `@Tool.Method` and `@Tool.Param` annotations for creating tools from annotated methods.
This approach is similar to Spring AI's `@Tool` but uses Embabel's framework-agnostic abstractions.

[tabs]
====
Java::
+
[source,java]
----
public class MathService {

    @Tool.Method(description = "Adds two numbers together")
    public int add(
            @Tool.Param(description = "First number") int a,
            @Tool.Param(description = "Second number") int b) {
        return a + b;
    }

    @Tool.Method(description = "Multiplies two numbers")
    public int multiply(
            @Tool.Param(description = "First number") int a,
            @Tool.Param(description = "Second number") int b) {
        return a * b;
    }
}

// Create tools from all annotated methods on an instance
List<Tool> mathTools = Tool.fromInstance(new MathService());

// Or safely create tools (returns empty list if no annotations found)
List<Tool> tools = Tool.safelyFromInstance(someObject);
----

Kotlin::
+
[source,kotlin]
----
class MathService {

    @Tool.Method(description = "Adds two numbers together")
    fun add(
        @Tool.Param(description = "First number") a: Int,
        @Tool.Param(description = "Second number") b: Int,
    ): Int = a + b

    @Tool.Method(description = "Multiplies two numbers")
    fun multiply(
        @Tool.Param(description = "First number") a: Int,
        @Tool.Param(description = "Second number") b: Int,
    ): Int = a * b
}

// Create tools from all annotated methods on an instance
val mathTools = Tool.fromInstance(MathService())

// Or safely create tools (returns empty list if no annotations found)
val tools = Tool.safelyFromInstance(someObject)
----
====

The `@Tool.Method` annotation supports:

- `name`: Tool name (defaults to method name if empty)
- `description`: Description of what the tool does (required)
- `returnDirect`: Whether to return the result directly without further LLM processing

The `@Tool.Param` annotation supports:

- `description`: Description of the parameter (helps the LLM understand what to provide)
- `required`: Whether the parameter is required (defaults to true)

===== Adding Framework-Agnostic Tools via PromptRunner

Use `withTool()` or `withTools()` to add framework-agnostic tools to a `PromptRunner`:

[tabs]
====
Java::
+
[source,java]
----
// Add a single tool
Tool calculatorTool = Tool.create("calculate", "Performs calculations",
    (input, ctx) -> Tool.Result.text("Result: 42"));

context.ai()
    .withDefaultLlm()
    .withTool(calculatorTool)
    .createObject("Calculate 6 * 7", MathResult.class);

// Add tools from annotated methods
List<Tool> mathTools = Tool.fromInstance(new MathService());

context.ai()
    .withDefaultLlm()
    .withTools(mathTools)
    .createObject("Add 5 and 3", MathResult.class);

// Combine with other tool sources
context.ai()
    .withDefaultLlm()
    .withToolGroup(CoreToolGroups.WEB)  // Tool group
    .withToolObject(domainObject)        // Spring AI @Tool methods
    .withTools(mathTools)                // Framework-agnostic tools
    .createObject("Research and calculate", Report.class);
----

Kotlin::
+
[source,kotlin]
----
// Add a single tool
val calculatorTool = Tool.of("calculate", "Performs calculations") { _, _ ->
    Tool.Result.text("Result: 42")
}

context.ai()
    .withDefaultLlm()
    .withTool(calculatorTool)
    .createObject("Calculate 6 * 7", MathResult::class.java)

// Add tools from annotated methods
val mathTools = Tool.fromInstance(MathService())

context.ai()
    .withDefaultLlm()
    .withTools(mathTools)
    .createObject("Add 5 and 3", MathResult::class.java)

// Combine with other tool sources
context.ai()
    .withDefaultLlm()
    .withToolGroup(CoreToolGroups.WEB)  // Tool group
    .withToolObject(domainObject)        // Spring AI @Tool methods
    .withTools(mathTools)                // Framework-agnostic tools
    .createObject("Research and calculate", Report::class.java)
----
====

===== Tool Results

Tools return `Tool.Result` which can be one of three types:

[source,kotlin]
----
// Text result (most common)
Tool.Result.text("The answer is 42")

// Result with an artifact (e.g., generated file, image)
Tool.Result.withArtifact("Generated report", reportBytes)

// Error result
Tool.Result.error("Failed to process request", exception)
----

===== When to Use Each Approach

|===
|Approach |Use When

|Spring AI `@Tool`
|You're comfortable with Spring AI and want IDE support for tool annotations on domain objects

|`Tool.create()` / `Tool.of()`
|You need programmatic tool creation, want framework independence, or are creating tools dynamically

|`@Tool.Method` / `@Tool.Param`
|You prefer annotation-based tools but want Embabel's framework-agnostic abstractions

|Tool Groups
|You need to organize related tools, use MCP servers, or control tool availability at deployment time
|===
